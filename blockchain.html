<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blockchain Miner | Transaction Ledger</title>
    <!-- Firebase SDKs -->
    <script src="https://www.gstatic.com/firebasejs/10.7.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.0/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.0/firebase-functions-compat.js"></script>
    <!-- CryptoJS for SHA256 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
    <style>
        :root {
            --primary: #2d3748;
            --secondary: #4a5568;
            --accent: #3182ce;
            --success: #38a169;
            --warning: #d69e2e;
            --danger: #e53e3e;
            --light: #f7fafc;
            --dark: #1a202c;
            --gray: #e2e8f0;
            --shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            --radius: 8px;
            --transition: all 0.3s ease;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
        }

        body {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: var(--dark);
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        /* Header & Auth Styles */
        .header {
            background: white;
            border-radius: var(--radius);
            padding: 1.5rem 2rem;
            margin-bottom: 2rem;
            box-shadow: var(--shadow);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 1rem;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--primary);
        }

        .logo-icon {
            width: 36px;
            height: 36px;
            background: linear-gradient(45deg, var(--accent), #805ad5);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
        }

        .auth-section {
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        .user-info {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.5rem 1rem;
            background: var(--gray);
            border-radius: 50px;
        }

        .user-avatar {
            width: 32px;
            height: 32px;
            background: var(--accent);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
        }

        /* Input & Button Styles */
        .input-group {
            display: flex;
            gap: 0.5rem;
            flex: 1;
            min-width: 300px;
        }

        input {
            padding: 0.75rem 1rem;
            border: 2px solid var(--gray);
            border-radius: var(--radius);
            font-size: 0.95rem;
            transition: var(--transition);
            flex: 1;
        }

        input:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 3px rgba(49, 130, 206, 0.2);
        }

        .btn {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: var(--radius);
            font-weight: 600;
            cursor: pointer;
            transition: var(--transition);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }

        .btn-primary {
            background: var(--accent);
            color: white;
        }

        .btn-primary:hover {
            background: #2c5282;
            transform: translateY(-2px);
        }

        .btn-success {
            background: var(--success);
            color: white;
        }

        .btn-success:hover {
            background: #2f855a;
        }

        .btn-warning {
            background: var(--warning);
            color: white;
        }

        .btn-warning:hover {
            background: #b7791f;
        }

        .btn-logout {
            background: var(--danger);
            color: white;
            padding: 0.5rem 1rem;
            font-size: 0.875rem;
        }

        /* Dashboard Styles */
        .dashboard {
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: 2rem;
        }

        .card {
            background: white;
            border-radius: var(--radius);
            padding: 1.5rem;
            box-shadow: var(--shadow);
            margin-bottom: 1.5rem;
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 2px solid var(--gray);
        }

        .card-title {
            font-size: 1.25rem;
            font-weight: 700;
            color: var(--primary);
        }

        .status-badge {
            padding: 0.25rem 0.75rem;
            border-radius: 50px;
            font-size: 0.75rem;
            font-weight: 600;
        }

        .status-mined {
            background: #c6f6d5;
            color: #22543d;
        }

        .status-pending {
            background: #fed7d7;
            color: #742a2a;
        }

        /* Blocks Grid */
        .blocks-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 1.5rem;
            max-height: 600px;
            overflow-y: auto;
            padding: 0.5rem;
        }

        .block-card {
            background: white;
            border-radius: var(--radius);
            padding: 1.25rem;
            box-shadow: var(--shadow);
            border-left: 4px solid var(--accent);
            transition: var(--transition);
        }

        .block-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.15);
        }

        .block-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .block-number {
            font-weight: 700;
            color: var(--accent);
            font-size: 1.1rem;
        }

        .block-hash {
            font-family: monospace;
            font-size: 0.8rem;
            color: var(--secondary);
            word-break: break-all;
            background: var(--gray);
            padding: 0.5rem;
            border-radius: 4px;
            margin: 0.5rem 0;
        }

        .block-data {
            font-size: 0.9rem;
            color: var(--secondary);
        }

        .data-row {
            display: flex;
            justify-content: space-between;
            margin: 0.5rem 0;
        }

        .data-label {
            font-weight: 600;
        }

        /* Mining Console */
        .mining-console {
            background: var(--dark);
            color: white;
            border-radius: var(--radius);
            padding: 1.5rem;
            height: fit-content;
        }

        .console-title {
            color: white;
            margin-bottom: 1.5rem;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .console-output {
            background: #1a202c;
            border-radius: 4px;
            padding: 1rem;
            font-family: monospace;
            font-size: 0.875rem;
            height: 300px;
            overflow-y: auto;
            margin-bottom: 1rem;
            border: 1px solid #4a5568;
        }

        .console-line {
            margin: 0.5rem 0;
            line-height: 1.4;
        }

        .console-line.info {
            color: #63b3ed;
        }

        .console-line.success {
            color: #68d391;
        }

        .console-line.warning {
            color: #f6e05e;
        }

        .console-line.error {
            color: #fc8181;
        }

        /* Stats Panel */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1rem;
            margin-top: 1.5rem;
        }

        .stat-card {
            background: rgba(255, 255, 255, 0.1);
            padding: 1rem;
            border-radius: 6px;
            text-align: center;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: white;
            margin: 0.5rem 0;
        }

        .stat-label {
            font-size: 0.875rem;
            color: #a0aec0;
        }

        /* Login Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: white;
            border-radius: var(--radius);
            padding: 2rem;
            width: 100%;
            max-width: 400px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
        }

        .modal-title {
            font-size: 1.5rem;
            margin-bottom: 1.5rem;
            text-align: center;
            color: var(--primary);
        }

        .form-group {
            margin-bottom: 1.5rem;
        }

        .form-label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 600;
            color: var(--secondary);
        }

        /* Loader */
        .loader {
            border: 4px solid var(--gray);
            border-top: 4px solid var(--accent);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 2rem auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Responsive */
        @media (max-width: 1024px) {
            .dashboard {
                grid-template-columns: 1fr;
            }
            
            .input-group {
                min-width: 100%;
            }
        }

        @media (max-width: 768px) {
            .header {
                flex-direction: column;
                text-align: center;
            }
            
            .auth-section {
                width: 100%;
                justify-content: center;
            }
            
            .blocks-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <header class="header">
            <div class="logo">
                <div class="logo-icon">‚õìÔ∏è</div>
                Blockchain Miner
            </div>
            
            <div id="authSection" class="auth-section">
                <!-- Login form shown when not authenticated -->
                <div id="loginForm">
                    <button onclick="showLoginModal()" class="btn btn-primary">
                        <span>üîë</span> Login to Mine
                    </button>
                </div>
                
                <!-- User info shown when authenticated -->
                <div id="userInfo" class="user-info" style="display: none;">
                    <div class="user-avatar" id="userAvatar">U</div>
                    <div>
                        <div id="userEmail"></div>
                        <button onclick="logout()" class="btn-logout">Logout</button>
                    </div>
                </div>
            </div>
        </header>

        <!-- Main Dashboard -->
        <div id="dashboard" style="display: none;">
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title">Mining Control Panel</h2>
                    <div class="input-group">
                        <input type="text" id="xyzAddress" placeholder="Enter your XYZ wallet address for rewards..." />
                        <button onclick="startMining()" class="btn btn-success">‚öíÔ∏è Start Mining</button>
                        <button onclick="viewBlockchain()" class="btn btn-primary">üîç View Blockchain</button>
                    </div>
                </div>
                
                <div class="dashboard">
                    <!-- Blockchain Display -->
                    <div>
                        <h3 style="margin-bottom: 1rem; color: var(--primary);">Blockchain Structure</h3>
                        <div id="blocksContainer" class="blocks-grid">
                            <!-- Blocks will be dynamically inserted here -->
                        </div>
                    </div>
                    
                    <!-- Mining Console -->
                    <div class="mining-console">
                        <h3 class="console-title">‚õèÔ∏è Mining Console</h3>
                        <div id="consoleOutput" class="console-output">
                            <div class="console-line info">Welcome to Blockchain Miner</div>
                            <div class="console-line info">Connect your XYZ wallet and start mining</div>
                            <div class="console-line info">Each block contains 100 transactions</div>
                            <div class="console-line info">Rewards are sent directly to your XYZ address</div>
                        </div>
                        
                        <div class="stats-grid">
                            <div class="stat-card">
                                <div class="stat-label">Blocks Mined</div>
                                <div id="blocksMined" class="stat-value">0</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-label">Transactions</div>
                                <div id="totalTransactions" class="stat-value">0</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-label">Rewards</div>
                                <div id="totalRewards" class="stat-value">0 XYZ</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-label">Mining Status</div>
                                <div id="miningStatus" class="stat-value">Idle</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Login Modal -->
        <div id="loginModal" class="modal">
            <div class="modal-content">
                <h2 class="modal-title">Login to Blockchain Miner</h2>
                <div class="form-group">
                    <label class="form-label">Email Address</label>
                    <input type="email" id="loginEmail" placeholder="user@example.com" />
                </div>
                <div class="form-group">
                    <label class="form-label">Password</label>
                    <input type="password" id="loginPassword" placeholder="Enter password" />
                </div>
                <button onclick="login()" class="btn btn-primary" style="width: 100%;">Login</button>
                <p style="text-align: center; margin-top: 1rem; color: var(--secondary);">
                    Test: admin@miner.com / password123
                </p>
            </div>
        </div>
    </div>

    <script>
const firebaseConfig = {
    apiKey: "AIzaSyDIwoUIMJrJQeLBD9vijsfIUXG9BgaGSPs",
    authDomain: "miner-zyx.firebaseapp.com",
    projectId: "miner-zyx",
    storageBucket: "miner-zyx.appspot.com",
    messagingSenderId: "430019680448",
    appId: "1:430019680448:web:d066b8aaf4355907e1b525",
    measurementId: "G-V6SDWYH6M2"
};

// Initialize Firebase
firebase.initializeApp(firebaseConfig);
const auth = firebase.auth();
const db = firebase.firestore();

// ==================== CHANGED TO 250 ====================
const TRANSACTIONS_PER_BLOCK = 250;  // CHANGED FROM 100 TO 250
const MINING_REWARD = 5.0;
const DIFFICULTY = 4;

// Global State
let currentUser = null;
let blockchain = null;
let isMining = false;
let miningInterval = null;
let lastProcessedTimestamp = null;

// ====================
// DIAGNOSTIC FUNCTIONS
// ====================

async function diagnoseTransactionAvailability() {
    logToConsole('=== DIAGNOSTIC: Checking transaction availability ===', 'info');
    
    try {
        // Check total transactions in blockchain
        const totalSnapshot = await db.collection('blockchain').get();
        logToConsole(`Total transactions in database: ${totalSnapshot.size}`, 'info');
        
        // Check by status
        const pendingSnapshot = await db.collection('blockchain')
            .where('status', '==', 'pending')
            .get();
        
        const confirmedSnapshot = await db.collection('blockchain')
            .where('status', '==', 'confirmed')
            .get();
        
        const noStatusSnapshot = await db.collection('blockchain')
            .where('status', '==', null)
            .get();
        
        const otherStatusSnapshot = await db.collection('blockchain')
            .where('status', 'not-in', ['pending', 'confirmed', null])
            .get();
        
        logToConsole(`Pending transactions: ${pendingSnapshot.size}`, 
            pendingSnapshot.size > 0 ? 'success' : 'warning');
        logToConsole(`Confirmed transactions: ${confirmedSnapshot.size}`, 'info');
        logToConsole(`Transactions without status: ${noStatusSnapshot.size}`, 
            noStatusSnapshot.size > 0 ? 'warning' : 'info');
        logToConsole(`Other status transactions: ${otherStatusSnapshot.size}`, 'info');
        
        // Check blockIndex distribution
        const noBlockIndexSnapshot = await db.collection('blockchain')
            .where('blockIndex', '==', null)
            .get();
        
        const hasBlockIndexSnapshot = await db.collection('blockchain')
            .where('blockIndex', '!=', null)
            .get();
        
        logToConsole(`Transactions without blockIndex: ${noBlockIndexSnapshot.size}`, 
            noBlockIndexSnapshot.size > 0 ? 'success' : 'info');
        logToConsole(`Transactions with blockIndex: ${hasBlockIndexSnapshot.size}`, 'info');
        
        // Show sample pending transactions
        if (pendingSnapshot.size > 0) {
            logToConsole(`=== Sample of ${Math.min(3, pendingSnapshot.size)} pending transactions ===`, 'info');
            pendingSnapshot.docs.slice(0, 3).forEach((doc, idx) => {
                const data = doc.data();
                logToConsole(`${idx + 1}. ${data.from} ‚Üí ${data.to} (${data.amount}) - ${data.timestamp}`, 'info');
            });
        }
        
        // Calculate how many blocks we can create
        const availableForMining = pendingSnapshot.size + noStatusSnapshot.size;
        const blocksPossible = Math.floor(availableForMining / TRANSACTIONS_PER_BLOCK);
        
        logToConsole(`=== MINING CAPACITY ===`, 'info');
        logToConsole(`Transactions available for mining: ${availableForMining}`, 
            availableForMining >= TRANSACTIONS_PER_BLOCK ? 'success' : 'warning');
        logToConsole(`Possible blocks: ${blocksPossible}`, 
            blocksPossible > 0 ? 'success' : 'warning');
        logToConsole(`Transactions per block required: ${TRANSACTIONS_PER_BLOCK}`, 'info');
        
        if (availableForMining < TRANSACTIONS_PER_BLOCK) {
            logToConsole(`‚ùå NOT ENOUGH TRANSACTIONS: Need ${TRANSACTIONS_PER_BLOCK - availableForMining} more transactions to create a block`, 'error');
        }
        
    } catch (error) {
        logToConsole(`Diagnostic error: ${error.message}`, 'error');
    }
}

// ====================
// UPDATED MIGRATION FUNCTION FOR 250 TRANSACTIONS
// ====================

async function migrateExistingTransactions() {
    const user = firebase.auth().currentUser;
    
    if (!user) {
        alert('Please login first to run migration');
        return;
    }
    
    console.log('Starting migration of existing transactions...');
    logToConsole('Starting migration of existing transactions...', 'info');
    logToConsole(`Target: ${TRANSACTIONS_PER_BLOCK} transactions per block`, 'info');
    
    try {
        // Get ALL transactions from blockchain collection
        const snapshot = await db.collection('blockchain').get();
        
        console.log(`Found ${snapshot.size} transactions to migrate`);
        logToConsole(`Found ${snapshot.size} transactions to migrate`, 'info');
        
        // Update in batches of 500
        let batch = db.batch();
        let count = 0;
        let updatedCount = 0;
        const totalDocs = snapshot.size;
        
        snapshot.forEach(doc => {
            const data = doc.data();
            const updates = {};
            
            // ========== CRITICAL CHANGE ==========
            // Reset ALL transactions to pending (so they can be mined into 250-block batches)
            updates.status = 'pending';  // Force all to pending
            
            // Reset block references (so they can be re-mined into new blocks)
            updates.blockIndex = null;
            updates.blockHash = null;
            updates.confirmedAt = null;
            
            // Calculate transaction hash if missing
            if (!data.transactionHash) {
                const txString = JSON.stringify({
                    from: data.from || '',
                    to: data.to || '',
                    amount: data.amount || 0,
                    timestamp: data.timestamp || new Date().toISOString(),
                    gasFee: data.gasFee || 0
                });
                updates.transactionHash = CryptoJS.SHA256(txString).toString();
            }
            
            // Ensure timestamp is in correct format
            if (data.timestamp && typeof data.timestamp === 'string') {
                updates.timestamp = data.timestamp;
            } else if (data.timestamp && data.timestamp.toDate) {
                // Convert Firestore timestamp to ISO string
                updates.timestamp = data.timestamp.toDate().toISOString();
            } else if (!data.timestamp) {
                // Set default timestamp
                updates.timestamp = new Date().toISOString();
            }
            
            // Add to batch if any updates needed
            if (Object.keys(updates).length > 0) {
                batch.update(doc.ref, updates);
                updatedCount++;
                count++;
                
                // Commit every 500 documents
                if (count % 500 === 0) {
                    batch.commit().then(() => {
                        console.log(`Migrated ${count}/${totalDocs} transactions...`);
                        logToConsole(`Migrated ${count}/${totalDocs} transactions...`, 'info');
                    });
                    // Start new batch
                    batch = db.batch();
                }
            }
        });
        
        // Commit remaining updates
        if (count > 0 && count % 500 !== 0) {
            await batch.commit();
        }
        
        console.log(`‚úÖ MIGRATION COMPLETE: Updated ${updatedCount} transactions`);
        logToConsole(`‚úÖ MIGRATION COMPLETE: Updated ${updatedCount} transactions`, 'success');
        logToConsole(`All transactions reset to 'pending' for ${TRANSACTIONS_PER_BLOCK}-transaction blocks`, 'success');
        
        // Clear existing blocks to start fresh
        await clearExistingBlocks();
        
        // Now initialize the blockchain with migrated data
        await initializeFirstBlocks(true);
        
    } catch (error) {
        console.error('Migration error:', error);
        logToConsole(`Migration failed: ${error.message}`, 'error');
        alert('Migration failed: ' + error.message);
    }
}

async function clearExistingBlocks() {
    try {
        logToConsole('Clearing existing blocks for fresh start...', 'info');
        
        // Delete all blocks
        const blocksSnapshot = await db.collection('blocks').get();
        const batch = db.batch();
        
        blocksSnapshot.docs.forEach(doc => {
            batch.delete(doc.ref);
        });
        
        // Delete confirmed transactions
        const confirmedSnapshot = await db.collection('confirmed_transactions').get();
        confirmedSnapshot.docs.forEach(doc => {
            batch.delete(doc.ref);
        });
        
        await batch.commit();
        logToConsole(`Cleared ${blocksSnapshot.size} blocks and ${confirmedSnapshot.size} confirmed transactions`, 'success');
        
    } catch (error) {
        logToConsole(`Error clearing blocks: ${error.message}`, 'error');
    }
}

// ====================
// UPDATED TRANSACTION QUERY FUNCTIONS FOR 250 TRANSACTIONS
// ====================

async function getNewTransactions() {
    try {
        logToConsole(`Searching for ${TRANSACTIONS_PER_BLOCK} transactions...`, 'info');
        
        // FIRST: Check how many pending transactions we have
        const pendingCount = await db.collection('blockchain')
            .where('status', '==', 'pending')
            .get()
            .then(snap => snap.size);
        
        logToConsole(`Found ${pendingCount} pending transactions in total`, 'info');
        
        // If we have enough pending transactions, use them
        if (pendingCount >= TRANSACTIONS_PER_BLOCK) {
            const snapshot = await db.collection('blockchain')
                .where('status', '==', 'pending')
                .orderBy('timestamp', 'asc')
                .limit(TRANSACTIONS_PER_BLOCK * 2) // Get extra to ensure we have enough
                .get();
            
            const newTransactions = [];
            snapshot.forEach(doc => {
                const data = doc.data();
                // Double-check status and ensure not already in a block
                if (data.status === 'pending' && (!data.blockIndex && data.blockIndex !== 0)) {
                    newTransactions.push({
                        originalId: doc.id,
                        ...data
                    });
                }
                
                // Stop when we have enough
                if (newTransactions.length >= TRANSACTIONS_PER_BLOCK) {
                    return;
                }
            });
            
            logToConsole(`Retrieved ${newTransactions.length} pending transactions for mining`, 
                newTransactions.length >= TRANSACTIONS_PER_BLOCK ? 'success' : 'warning');
            return newTransactions.slice(0, TRANSACTIONS_PER_BLOCK);
        }
        
        // ==================== FIND ALL UNMINED TRANSACTIONS ====================
        logToConsole(`Not enough pending transactions (${pendingCount}). Searching for all unmined transactions...`, 'warning');
        
        // Get a large batch of transactions
        const allSnapshot = await db.collection('blockchain')
            .orderBy('timestamp', 'asc')
            .limit(TRANSACTIONS_PER_BLOCK * 3) // Get 3x what we need
            .get();
        
        const unminedTransactions = [];
        let processedCount = 0;
        
        allSnapshot.forEach(doc => {
            const data = doc.data();
            processedCount++;
            
            // Include transactions that are NOT confirmed AND not in a block
            const isUnmined = (!data.blockIndex && data.blockIndex !== 0) || 
                              data.status !== 'confirmed';
            
            if (isUnmined) {
                unminedTransactions.push({
                    originalId: doc.id,
                    ...data,
                    // Ensure status is set to pending
                    status: 'pending'
                });
            }
            
            // Stop when we have enough
            if (unminedTransactions.length >= TRANSACTIONS_PER_BLOCK) {
                return;
            }
        });
        
        logToConsole(`Processed ${processedCount} transactions, found ${unminedTransactions.length} unmined transactions`, 'info');
        
        // If we found transactions, update their status to pending
        if (unminedTransactions.length > 0) {
            await updateTransactionStatuses(unminedTransactions);
        }
        
        return unminedTransactions.slice(0, TRANSACTIONS_PER_BLOCK);
        
    } catch (error) {
        logToConsole(`Error fetching transactions: ${error.message}`, 'error');
        console.error('Full error:', error);
        return await getNewTransactionsFallback();
    }
}

async function updateTransactionStatuses(transactions) {
    try {
        const batch = db.batch();
        let updatedCount = 0;
        
        for (const tx of transactions.slice(0, 250)) { // Limit to 250
            const txRef = db.collection('blockchain').doc(tx.originalId);
            
            // Update to pending and clear block references
            batch.update(txRef, {
                status: 'pending',
                blockIndex: null,
                blockHash: null,
                confirmedAt: null
            });
            updatedCount++;
        }
        
        if (updatedCount > 0) {
            await batch.commit();
            logToConsole(`Updated ${updatedCount} transactions to 'pending' status`, 'success');
        }
        
    } catch (error) {
        logToConsole(`Error updating transaction statuses: ${error.message}`, 'error');
    }
}

async function getNewTransactionsFallback() {
    try {
        logToConsole('Using fallback transaction query...', 'warning');
        
        // Get ALL transactions ordered by timestamp
        const snapshot = await db.collection('blockchain')
            .orderBy('timestamp', 'asc')
            .limit(TRANSACTIONS_PER_BLOCK * 4) // Get 4x what we need
            .get();
        
        const allTransactions = [];
        snapshot.forEach(doc => {
            allTransactions.push({
                originalId: doc.id,
                ...doc.data()
            });
        });
        
        logToConsole(`Retrieved ${allTransactions.length} total transactions`, 'info');
        
        // Filter for unmined transactions (no blockIndex or not confirmed)
        const unmined = allTransactions.filter(tx => {
            const hasNoBlock = !tx.blockIndex && tx.blockIndex !== 0;
            const isNotConfirmed = tx.status !== 'confirmed';
            return hasNoBlock || isNotConfirmed;
        });
        
        // Sort by timestamp (oldest first)
        unmined.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
        
        logToConsole(`Found ${unmined.length} unmined transactions (fallback)`, 
            unmined.length >= TRANSACTIONS_PER_BLOCK ? 'success' : 'warning');
        
        // Update status for these transactions
        if (unmined.length > 0) {
            await updateTransactionStatuses(unmined);
        }
        
        // Take only what we need
        return unmined.slice(0, TRANSACTIONS_PER_BLOCK);
        
    } catch (error) {
        logToConsole(`Fallback query failed: ${error.message}`, 'error');
        return [];
    }
}

// ====================
// UPDATED BLOCKCHAIN CLASS FOR 250 TRANSACTIONS
// ====================

class Blockchain {
    constructor() {
        this.chain = [this.createGenesisBlock()];
        this.pendingTransactions = [];
        this.difficulty = DIFFICULTY;
    }

    createGenesisBlock() {
        return new Block(0, new Date().toISOString(), [{
            from: 'GENESIS',
            to: 'NETWORK',
            amount: 0,
            timestamp: new Date().toISOString(),
            type: 'genesis',
            status: 'confirmed'
        }], '0'.repeat(64));
    }

    getLatestBlock() {
        return this.chain[this.chain.length - 1];
    }

    async addBlock(newBlock) {
        newBlock.previousHash = this.getLatestBlock().hash;
        
        // Mine the block
        logToConsole(`Mining block ${newBlock.index} with ${newBlock.transactions.length} transactions...`, 'info');
        const hash = newBlock.mineBlock(this.difficulty);
        logToConsole(`Block ${newBlock.index} mined! Nonce: ${newBlock.nonce}, Hash: ${hash.substring(0, 16)}...`, 'success');
        logToConsole(`Transactions in block: ${newBlock.transactions.length}`, 'info');
        
        this.chain.push(newBlock);
        
        // Save to Firebase
        await this.saveBlockToFirebase(newBlock);
        
        return newBlock;
    }

    async saveBlockToFirebase(block) {
        try {
            const blockData = {
                index: block.index,
                timestamp: block.timestamp,
                transactionCount: block.transactions.length,
                previousHash: block.previousHash,
                hash: block.hash,
                nonce: block.nonce,
                merkleRoot: block.merkleRoot,
                difficulty: this.difficulty,
                minedBy: currentUser ? currentUser.email : 'system',
                minedAt: new Date().toISOString(),
                transactionsPerBlock: TRANSACTIONS_PER_BLOCK  // Track the block size
            };

            // Save block metadata
            await db.collection('blocks').doc(`block_${block.index}`).set(blockData);
            
            // Process each transaction
            const batch = db.batch();
            let transactionIndex = 0;
            let confirmedCount = 0;
            
            for (const transaction of block.transactions) {
                if (transaction.type === 'mining_reward' || transaction.from === 'BLOCK_REWARD') {
                    // Save mining reward
                    const rewardRef = db.collection('rewards').doc();
                    batch.set(rewardRef, {
                        ...transaction,
                        blockIndex: block.index,
                        blockHash: block.hash,
                        minedAt: new Date().toISOString(),
                        transactionIndex: transactionIndex,
                        minedBy: currentUser.email
                    });
                    
                    // Also save to user_rewards
                    const xyzAddress = document.getElementById('xyzAddress') ? 
                        document.getElementById('xyzAddress').value : currentUser.email;
                    const userRewardRef = db.collection('user_rewards').doc();
                    batch.set(userRewardRef, {
                        userId: currentUser.uid,
                        email: currentUser.email,
                        xyzAddress: xyzAddress || currentUser.email,
                        amount: transaction.amount,
                        blockHash: block.hash,
                        blockIndex: block.index,
                        timestamp: new Date().toISOString(),
                        status: 'distributed'
                    });
                    
                } else if (transaction.originalId) {
                    // ========== UPDATE ORIGINAL TRANSACTION ==========
                    const txRef = db.collection('blockchain').doc(transaction.originalId);
                    
                    batch.update(txRef, {
                        status: 'confirmed',
                        blockIndex: block.index,
                        blockHash: block.hash,
                        confirmedAt: new Date().toISOString(),
                        transactionIndex: transactionIndex
                    });
                    confirmedCount++;
                    
                    // Save to confirmed_transactions collection
                    const confirmedRef = db.collection('confirmed_transactions').doc(transaction.originalId);
                    batch.set(confirmedRef, {
                        ...transaction,
                        blockIndex: block.index,
                        blockHash: block.hash,
                        confirmedAt: new Date().toISOString(),
                        minedBy: currentUser.email,
                        transactionIndex: transactionIndex
                    });
                }
                
                transactionIndex++;
            }
            
            await batch.commit();
            
            logToConsole(`‚úÖ Block ${block.index} saved. ${confirmedCount} transactions confirmed.`, 'success');
            
            // Update mining stats
            await updateMiningStats(block.index, block.transactions.length);
            
        } catch (error) {
            logToConsole(`‚ùå Error saving block: ${error.message}`, 'error');
            console.error('Save error details:', error);
        }
    }

    isChainValid() {
        for (let i = 1; i < this.chain.length; i++) {
            const currentBlock = this.chain[i];
            const previousBlock = this.chain[i - 1];

            if (currentBlock.hash !== currentBlock.calculateHash()) {
                logToConsole(`Block ${i} hash invalid`, 'error');
                return false;
            }

            if (currentBlock.previousHash !== previousBlock.hash) {
                logToConsole(`Block ${i} previous hash mismatch`, 'error');
                return false;
            }

            if (currentBlock.hash.substring(0, this.difficulty) !== '0'.repeat(this.difficulty)) {
                logToConsole(`Block ${i} doesn't meet difficulty`, 'error');
                return false;
            }
        }
        return true;
    }
}

class Block {
    constructor(index, timestamp, transactions, previousHash = '', nonce = 0) {
        this.index = index;
        this.timestamp = timestamp;
        this.transactions = transactions;
        this.previousHash = previousHash;
        this.nonce = nonce;
        this.merkleRoot = this.calculateMerkleRoot();
        this.hash = this.calculateHash();
    }

    calculateHash() {
        const blockString = 
            this.index + 
            this.timestamp + 
            JSON.stringify(this.transactions) + 
            this.previousHash + 
            this.nonce + 
            this.merkleRoot;
        
        return CryptoJS.SHA256(blockString).toString();
    }

    calculateMerkleRoot() {
        if (this.transactions.length === 0) {
            return CryptoJS.SHA256("").toString();
        }

        let transactionHashes = this.transactions.map(tx => {
            // Create transaction hash
            const txString = JSON.stringify({
                from: tx.from,
                to: tx.to,
                amount: tx.amount,
                timestamp: tx.timestamp,
                type: tx.type || 'transfer'
            });
            return CryptoJS.SHA256(txString).toString();
        });

        while (transactionHashes.length > 1) {
            const newLevel = [];
            
            for (let i = 0; i < transactionHashes.length; i += 2) {
                const left = transactionHashes[i];
                const right = (i + 1 < transactionHashes.length) ? 
                    transactionHashes[i + 1] : transactionHashes[i];
                
                const combined = left + right;
                newLevel.push(CryptoJS.SHA256(combined).toString());
            }
            
            transactionHashes = newLevel;
        }

        return transactionHashes[0];
    }

    mineBlock(difficulty) {
        const target = '0'.repeat(difficulty);
        let attempts = 0;
        const startTime = Date.now();
        
        while (this.hash.substring(0, difficulty) !== target) {
            this.nonce++;
            this.hash = this.calculateHash();
            attempts++;
            
            // Show progress every 50,000 attempts (more frequent for larger blocks)
            if (attempts % 50000 === 0) {
                const elapsed = Date.now() - startTime;
                logToConsole(`Mining... ${attempts.toLocaleString()} attempts, ${elapsed}ms`, 'info');
            }
        }
        
        const totalTime = Date.now() - startTime;
        logToConsole(`Mined in ${totalTime}ms with ${attempts.toLocaleString()} attempts`, 'success');
        return this.hash;
    }
}

// ====================
// UPDATED INITIALIZATION FOR 250 TRANSACTIONS
// ====================

async function initializeFirstBlocks(isMigration = false) {
    try {
        logToConsole(`Creating blockchain with ${TRANSACTIONS_PER_BLOCK} transactions per block...`, 'info');
        
        // Get all PENDING transactions
        const querySnapshot = await db.collection('blockchain')
            .where('status', '==', 'pending')
            .orderBy('timestamp', 'asc')
            .get();
        
        const transactions = [];
        querySnapshot.forEach(doc => {
            const data = doc.data();
            // Ensure we have all required fields
            transactions.push({
                originalId: doc.id,
                ...data,
                status: data.status || 'pending',
                timestamp: data.timestamp || new Date().toISOString()
            });
        });
        
        logToConsole(`Found ${transactions.length} pending transactions`, 'info');
        
        if (transactions.length === 0) {
            logToConsole('No pending transactions found.', 'warning');
            await diagnoseTransactionAvailability();
            return;
        }
        
        // Calculate how many full blocks we can create
        const fullBlocks = Math.floor(transactions.length / TRANSACTIONS_PER_BLOCK);
        const remainingTransactions = transactions.length % TRANSACTIONS_PER_BLOCK;
        
        logToConsole(`Can create ${fullBlocks} full blocks of ${TRANSACTIONS_PER_BLOCK} transactions`, 'info');
        logToConsole(`Remaining transactions: ${remainingTransactions}`, 'info');
        
        if (fullBlocks === 0) {
            logToConsole(`‚ùå NOT ENOUGH TRANSACTIONS: Need ${TRANSACTIONS_PER_BLOCK} transactions per block, but only have ${transactions.length}`, 'error');
            return;
        }
        
        // Group into blocks of TRANSACTIONS_PER_BLOCK transactions each
        for (let blockNum = 0; blockNum < fullBlocks; blockNum++) {
            const startIdx = blockNum * TRANSACTIONS_PER_BLOCK;
            const endIdx = startIdx + TRANSACTIONS_PER_BLOCK;
            const blockTransactions = transactions.slice(startIdx, endIdx);
            
            // Add mining reward transaction for the miner
            const rewardTx = {
                from: 'BLOCK_REWARD',
                to: currentUser.email,
                amount: MINING_REWARD,
                timestamp: new Date().toISOString(),
                type: 'mining_reward',
                gasFee: 0,
                status: 'confirmed'
            };
            
            blockTransactions.push(rewardTx);
            
            // Create the block
            const newBlock = new Block(
                blockchain.chain.length,  // Next block index
                new Date().toISOString(),
                blockTransactions,
                blockchain.getLatestBlock().hash
            );
            
            logToConsole(`Creating Block #${newBlock.index} with ${blockTransactions.length} transactions...`, 'info');
            logToConsole(`Transactions ${startIdx + 1} to ${endIdx} of ${transactions.length}`, 'info');
            
            // Mine and save the block
            await blockchain.addBlock(newBlock);
            
            logToConsole(`‚úÖ Block #${newBlock.index} created successfully with ${blockTransactions.length} transactions`, 'success');
            
            // Update UI
            updateBlocksDisplay();
            updateStats();
            
            // Small delay to prevent overwhelming the browser
            await new Promise(resolve => setTimeout(resolve, 1000));
        }
        
        logToConsole(`üéâ Created ${fullBlocks} blocks with ${TRANSACTIONS_PER_BLOCK} transactions each!`, 'success');
        
        if (remainingTransactions > 0) {
            logToConsole(`Note: ${remainingTransactions} transactions remaining (need ${TRANSACTIONS_PER_BLOCK - remainingTransactions} more for another block)`, 'info');
        }
        
    } catch (error) {
        logToConsole(`Error creating blocks: ${error.message}`, 'error');
        console.error('Full error:', error);
    }
}

async function loadExistingBlockchain() {
    blockchain = new Blockchain();
    blockchain.chain = [];
    
    // Load genesis block
    blockchain.chain.push(blockchain.createGenesisBlock());
    
    // Load other blocks
    const blocksSnapshot = await db.collection('blocks')
        .orderBy('index', 'asc')
        .get();
    
    for (const blockDoc of blocksSnapshot.docs) {
        if (blockDoc.data().index === 0) continue; // Skip genesis
        
        const blockData = blockDoc.data();
        
        // Load transactions for this block
        const transactionsSnapshot = await db.collection('confirmed_transactions')
            .where('blockIndex', '==', blockData.index)
            .get();
        
        const transactions = [];
        transactionsSnapshot.forEach(txDoc => {
            transactions.push(txDoc.data());
        });
        
        // Load rewards for this block
        const rewardsSnapshot = await db.collection('rewards')
            .where('blockIndex', '==', blockData.index)
            .get();
        
        rewardsSnapshot.forEach(rewardDoc => {
            transactions.push(rewardDoc.data());
        });
        
        const block = new Block(
            blockData.index,
            blockData.timestamp,
            transactions,
            blockData.previousHash,
            blockData.nonce
        );
        
        // Set the mined hash
        block.hash = blockData.hash;
        block.merkleRoot = blockData.merkleRoot;
        
        blockchain.chain.push(block);
        
        // Log block details
        logToConsole(`Loaded Block #${blockData.index} with ${transactions.length} transactions`, 'info');
    }
    
    logToConsole(`Loaded ${blockchain.chain.length - 1} blocks from database`, 'success');
}

async function initializeBlockchain() {
    logToConsole('Initializing blockchain system...', 'info');
    
    try {
        // Check if blocks exist
        const blocksSnapshot = await db.collection('blocks')
            .orderBy('index', 'desc')
            .limit(1)
            .get();
        
        if (blocksSnapshot.empty) {
            logToConsole('Creating new blockchain...', 'info');
            blockchain = new Blockchain();
            // Run diagnostic first
            await diagnoseTransactionAvailability();
        } else {
            logToConsole('Loading existing blockchain...', 'info');
            await loadExistingBlockchain();
        }
        
        updateStats();
        updateBlocksDisplay();
        
    } catch (error) {
        logToConsole(`Initialization error: ${error.message}`, 'error');
        blockchain = new Blockchain();
    }
}

// ====================
// UPDATED MINING FUNCTIONS FOR 250 TRANSACTIONS
// ====================

async function startMining() {
    if (isMining) {
        stopMining();
        return;
    }

    const xyzAddress = document.getElementById('xyzAddress').value.trim();
    if (!xyzAddress) {
        alert('Please enter your XYZ wallet address to receive mining rewards');
        return;
    }

    // Run diagnostic first
    await diagnoseTransactionAvailability();

    isMining = true;
    document.getElementById('miningStatus').textContent = 'Mining...';
    document.querySelector('.btn-success').innerHTML = '‚èπÔ∏è Stop Mining';
    
    logToConsole(`üöÄ Mining started for: ${xyzAddress}`, 'success');
    logToConsole(`‚õèÔ∏è  Difficulty: ${DIFFICULTY} | Reward: ${MINING_REWARD} XYZ | Transactions per block: ${TRANSACTIONS_PER_BLOCK}`, 'info');

    // Start mining loop
    miningInterval = setInterval(async () => {
        await mineNextBlock(xyzAddress);
    }, 15000); // Check every 15 seconds (longer for larger blocks)
}

async function mineNextBlock(xyzAddress) {
    try {
        logToConsole(`Attempting to mine block #${blockchain.chain.length}...`, 'info');
        
        // Get transactions for mining
        let pendingTx = await getNewTransactions();
        
        logToConsole(`Retrieved ${pendingTx.length} transactions`, 'info');
        
        // Check if we have enough transactions
        if (pendingTx.length < TRANSACTIONS_PER_BLOCK - 1) {
            logToConsole(`‚ùå INSUFFICIENT TRANSACTIONS: Only ${pendingTx.length} available, need ${TRANSACTIONS_PER_BLOCK - 1}`, 'error');
            logToConsole(`Waiting for more transactions...`, 'info');
            
            // Run diagnostic to see what's available
            await diagnoseTransactionAvailability();
            return;
        }
        
        // Take exactly TRANSACTIONS_PER_BLOCK - 1 transactions (leave 1 spot for reward)
        const transactionsToMine = pendingTx.slice(0, TRANSACTIONS_PER_BLOCK - 1);
        
        logToConsole(`Mining with ${transactionsToMine.length} regular transactions`, 'success');
        
        // Add mining reward as the 250th transaction
        transactionsToMine.push({
            from: 'BLOCK_REWARD',
            to: xyzAddress,
            amount: MINING_REWARD,
            timestamp: new Date().toISOString(),
            type: 'mining_reward',
            gasFee: 0,
            senderEmail: 'system',
            receiverEmail: currentUser.email,
            status: 'pending'
        });

        logToConsole(`Total transactions in block: ${transactionsToMine.length}`, 'info');

        const newBlock = new Block(
            blockchain.chain.length,
            new Date().toISOString(),
            transactionsToMine,
            blockchain.getLatestBlock().hash
        );

        // Mine and add block
        await blockchain.addBlock(newBlock);
        
        // Update UI
        updateBlocksDisplay();
        updateStats();
        
        // Send reward notification
        sendRewardNotification(xyzAddress, MINING_REWARD, newBlock.hash);
        
    } catch (error) {
        logToConsole(`Mining error: ${error.message}`, 'error');
        console.error('Mining error details:', error);
    }
}

function stopMining() {
    if (miningInterval) {
        clearInterval(miningInterval);
        miningInterval = null;
    }
    
    isMining = false;
    document.getElementById('miningStatus').textContent = 'Idle';
    document.querySelector('.btn-success').innerHTML = '‚öíÔ∏è Start Mining';
    logToConsole('Mining stopped', 'warning');
}

async function updateMiningStats(blockIndex, transactionCount) {
    try {
        // Update user stats
        const userRef = db.collection('users').doc(currentUser.uid);
        await userRef.set({
            email: currentUser.email,
            blocksMined: firebase.firestore.FieldValue.increment(1),
            totalTransactionsMined: firebase.firestore.FieldValue.increment(transactionCount),
            lastActive: new Date().toISOString(),
            lastBlockMined: blockIndex,
            transactionsPerBlock: TRANSACTIONS_PER_BLOCK
        }, { merge: true });
        
        // Update global stats
        const statsRef = db.collection('mining_stats').doc('global');
        await statsRef.set({
            totalBlocks: firebase.firestore.FieldValue.increment(1),
            totalTransactions: firebase.firestore.FieldValue.increment(transactionCount),
            lastUpdated: new Date().toISOString(),
            lastBlockIndex: blockIndex,
            currentTransactionsPerBlock: TRANSACTIONS_PER_BLOCK
        }, { merge: true });
        
    } catch (error) {
        console.error('Error updating stats:', error);
    }
}

function sendRewardNotification(address, amount, blockHash) {
    // Simulate reward distribution
    const rewardId = `reward_${Date.now()}`;
    
    db.collection('user_rewards').doc(rewardId).set({
        userId: currentUser.uid,
        email: currentUser.email,
        xyzAddress: address,
        amount: amount,
        blockHash: blockHash,
        blockIndex: blockchain.chain.length - 1,
        timestamp: new Date().toISOString(),
        status: 'distributed',
        transactionsInBlock: TRANSACTIONS_PER_BLOCK
    });
    
    logToConsole(`üí∞ ${amount} XYZ sent to ${address}`, 'success');
    logToConsole(`üì¶ Block ${blockchain.chain.length - 1}: ${blockHash.substring(0, 20)}...`, 'info');
    
    // Update rewards counter
    const rewardsElement = document.getElementById('totalRewards');
    const current = parseFloat(rewardsElement.textContent) || 0;
    rewardsElement.textContent = (current + amount).toFixed(2) + ' XYZ';
}

// ====================
// UI FUNCTIONS
// ====================

function updateBlocksDisplay() {
    const container = document.getElementById('blocksContainer');
    if (!container || !blockchain) return;
    
    container.innerHTML = '';
    
    // Show last 5 blocks
    const blocksToShow = [...blockchain.chain].reverse().slice(0, 5);
    
    blocksToShow.forEach(block => {
        const blockElement = document.createElement('div');
        blockElement.className = 'block-card';
        
        blockElement.innerHTML = `
            <div class="block-header">
                <div class="block-number">Block #${block.index}</div>
                <div class="status-badge ${block.index === 0 ? 'status-mined' : 'status-mined'}">
                    ${block.index === 0 ? 'GENESIS' : 'MINED'}
                </div>
            </div>
            <div class="block-hash" title="${block.hash}">
                ${block.hash.substring(0, 24)}...
            </div>
            <div class="block-data">
                <div class="data-row">
                    <span class="data-label">Transactions:</span>
                    <span>${block.transactions.length}/${TRANSACTIONS_PER_BLOCK}</span>
                </div>
                <div class="data-row">
                    <span class="data-label">Nonce:</span>
                    <span>${block.nonce.toLocaleString()}</span>
                </div>
                <div class="data-row">
                    <span class="data-label">Merkle Root:</span>
                    <span>${block.merkleRoot.substring(0, 16)}...</span>
                </div>
                <div class="data-row">
                    <span class="data-label">Timestamp:</span>
                    <span>${new Date(block.timestamp).toLocaleString()}</span>
                </div>
            </div>
        `;
        
        container.appendChild(blockElement);
    });
}

function updateStats() {
    if (!blockchain) return;
    
    let totalTransactions = 0;
    let totalRewards = 0;
    
    blockchain.chain.forEach(block => {
        totalTransactions += block.transactions.length;
        
        block.transactions.forEach(tx => {
            if (tx.type === 'mining_reward' || tx.from === 'BLOCK_REWARD') {
                totalRewards += parseFloat(tx.amount) || 0;
            }
        });
    });
    
    document.getElementById('blocksMined').textContent = blockchain.chain.length - 1;
    document.getElementById('totalTransactions').textContent = totalTransactions.toLocaleString();
    document.getElementById('totalRewards').textContent = totalRewards.toFixed(2) + ' XYZ';
    
    // Add transactions per block info
    const miningStatus = document.getElementById('miningStatus');
    if (miningStatus) {
        miningStatus.textContent = isMining ? 'Mining...' : 'Idle';
    }
}

function logToConsole(message, type = 'info') {
    const consoleOutput = document.getElementById('consoleOutput');
    if (!consoleOutput) return;
    
    const line = document.createElement('div');
    line.className = `console-line ${type}`;
    line.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
    
    consoleOutput.appendChild(line);
    consoleOutput.scrollTop = consoleOutput.scrollHeight;
}

// ====================
// ADD DIAGNOSTIC BUTTON TO UI
// ====================

function addDiagnosticButton() {
    const cardHeader = document.querySelector('.card-header');
    if (!cardHeader) return;
    
    // Check if button already exists
    if (document.getElementById('diagnosticBtn')) return;
    
    const diagnosticBtn = document.createElement('button');
    diagnosticBtn.id = 'diagnosticBtn';
    diagnosticBtn.className = 'btn btn-primary';
    diagnosticBtn.innerHTML = 'üîç Check Transactions';
    diagnosticBtn.onclick = diagnoseTransactionAvailability;
    diagnosticBtn.title = 'Check how many transactions are available for mining';
    diagnosticBtn.style.marginLeft = '10px';
    
    // Insert after the migration button or view button
    const migrationBtn = document.getElementById('migrationBtn');
    if (migrationBtn) {
        migrationBtn.parentNode.insertBefore(diagnosticBtn, migrationBtn.nextSibling);
    } else {
        const viewBtn = document.querySelector('button[onclick="viewBlockchain()"]');
        if (viewBtn) {
            viewBtn.parentNode.insertBefore(diagnosticBtn, viewBtn.nextSibling);
        } else {
            cardHeader.appendChild(diagnosticBtn);
        }
    }
}

// ====================
// SETUP FIREBASE STRUCTURE
// ====================

async function setupFirebaseStructure() {
    logToConsole('Setting up database structure...', 'info');
    
    // Add required fields to existing documents
    const batch = db.batch();
    const snapshot = await db.collection('blockchain').limit(50).get();
    
    let updated = 0;
    snapshot.forEach(doc => {
        const data = doc.data();
        const updates = {};
        
        if (!data.status) updates.status = 'pending';
        if (!data.timestamp) updates.timestamp = new Date().toISOString();
        if (!data.blockIndex && data.blockIndex !== 0) updates.blockIndex = null;
        if (!data.blockHash) updates.blockHash = null;
        
        if (Object.keys(updates).length > 0) {
            batch.update(doc.ref, updates);
            updated++;
        }
    });
    
    if (updated > 0) {
        await batch.commit();
        logToConsole(`Updated ${updated} transactions with required fields`, 'success');
    }
}

// ====================
// AUTH FUNCTIONS
// ====================

async function login() {
    const email = document.getElementById('loginEmail').value;
    const password = document.getElementById('loginPassword').value;
    
    try {
        const userCredential = await auth.signInWithEmailAndPassword(email, password);
        currentUser = userCredential.user;
        
        document.getElementById('loginForm').style.display = 'none';
        document.getElementById('userInfo').style.display = 'flex';
        document.getElementById('userEmail').textContent = currentUser.email;
        document.getElementById('userAvatar').textContent = currentUser.email.charAt(0).toUpperCase();
        document.getElementById('dashboard').style.display = 'block';
        
        hideLoginModal();
        logToConsole(`Welcome ${currentUser.email}!`, 'success');
        logToConsole(`Transactions per block: ${TRANSACTIONS_PER_BLOCK}`, 'info');
        
        // Add buttons to UI
        addMigrationButton();
        addDiagnosticButton();
        
        await initializeBlockchain();
        
    } catch (error) {
        logToConsole(`Login failed: ${error.message}`, 'error');
        alert('Login failed. Please check credentials.');
    }
}

function logout() {
    auth.signOut();
    currentUser = null;
    document.getElementById('loginForm').style.display = 'block';
    document.getElementById('userInfo').style.display = 'none';
    document.getElementById('dashboard').style.display = 'none';
    stopMining();
    logToConsole('Logged out', 'info');
}

function showLoginModal() {
    document.getElementById('loginModal').classList.add('active');
}

function hideLoginModal() {
    document.getElementById('loginModal').classList.remove('active');
}

// ====================
// ADD MIGRATION BUTTON TO UI
// ====================

function addMigrationButton() {
    const cardHeader = document.querySelector('.card-header');
    if (!cardHeader) return;
    
    // Check if button already exists
    if (document.getElementById('migrationBtn')) return;
    
    const migrationBtn = document.createElement('button');
    migrationBtn.id = 'migrationBtn';
    migrationBtn.className = 'btn btn-warning';
    migrationBtn.innerHTML = 'üîÑ Migrate for 250/blocks';
    migrationBtn.onclick = migrateExistingTransactions;
    migrationBtn.title = 'Reset all transactions and prepare for 250-transaction blocks';
    migrationBtn.style.marginLeft = '10px';
    
    // Insert after the View Blockchain button
    const viewBtn = document.querySelector('button[onclick="viewBlockchain()"]');
    if (viewBtn) {
        viewBtn.parentNode.insertBefore(migrationBtn, viewBtn.nextSibling);
    } else {
        cardHeader.appendChild(migrationBtn);
    }
}

// ====================
// VIEW BLOCKCHAIN FUNCTION
// ====================

function viewBlockchain() {
    logToConsole('=== BLOCKCHAIN VALIDATION ===', 'info');
    if (!blockchain) {
        logToConsole('Blockchain not initialized', 'error');
        return;
    }
    
    logToConsole(`Chain length: ${blockchain.chain.length} blocks`, 'info');
    logToConsole(`Chain valid: ${blockchain.isChainValid()}`, 
        blockchain.isChainValid() ? 'success' : 'error');
    
    blockchain.chain.forEach((block, index) => {
        logToConsole(`Block ${index}: ${block.hash.substring(0, 16)}... (${block.transactions.length} transactions)`, 'info');
    });
}

// ====================
// INITIALIZATION
// ====================

document.addEventListener('DOMContentLoaded', async () => {
    // Auth state listener
    auth.onAuthStateChanged((user) => {
        if (user) {
            currentUser = user;
            document.getElementById('loginForm').style.display = 'none';
            document.getElementById('userInfo').style.display = 'flex';
            document.getElementById('userEmail').textContent = user.email;
            document.getElementById('userAvatar').textContent = user.email.charAt(0).toUpperCase();
            document.getElementById('dashboard').style.display = 'block';
            
            logToConsole(`Session restored for ${user.email}`, 'success');
            
            // Add buttons
            addMigrationButton();
            addDiagnosticButton();
            
            initializeBlockchain();
        }
    });
    
    // Close modal on outside click
    document.getElementById('loginModal').addEventListener('click', (e) => {
        if (e.target.id === 'loginModal') hideLoginModal();
    });
    
    // Enter key in login form
    document.getElementById('loginPassword').addEventListener('keypress', (e) => {
        if (e.key === 'Enter') login();
    });
    
    // Setup database
    await setupFirebaseStructure();
    
    logToConsole('Blockchain Miner Ready', 'success');
    logToConsole(`Configuration: ${TRANSACTIONS_PER_BLOCK} transactions per block`, 'info');
    logToConsole('Please login to start mining', 'info');
});
    </script>
</body>
</html>
